import crypto from "node:crypto";
import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, "..");
const distDir = path.join(rootDir, "dist");

async function removeSpaceNamedFilesRec(dir) {
  let items = [];
  try {
    items = await fs.readdir(dir, { withFileTypes: true });
  } catch {
    return;
  }
  for (const it of items) {
    const abs = path.join(dir, it.name);
    if (it.isDirectory()) {
      await removeSpaceNamedFilesRec(abs);
      continue;
    }
    if (!it.isFile()) continue;
    // Build outputs should never contain spaces; files like "index 2.html" are usually conflict copies.
    if (it.name.includes(" ")) {
      try {
        await fs.unlink(abs);
      } catch {}
    }
  }
}

async function listFilesRec(dir, baseDir) {
  const out = [];
  const items = await fs.readdir(dir, { withFileTypes: true });
  for (const it of items) {
    const abs = path.join(dir, it.name);
    if (it.isDirectory()) {
      out.push(...(await listFilesRec(abs, baseDir)));
      continue;
    }
    if (!it.isFile()) continue;
    out.push(path.relative(baseDir, abs));
  }
  return out;
}

async function readJson(p) {
  const raw = await fs.readFile(p, "utf8");
  return JSON.parse(raw);
}

async function main() {
  const pkg = await readJson(path.join(rootDir, "package.json"));
  const version = String(pkg?.version ?? "0.0.0").trim() || "0.0.0";

  // Clean up conflict copies / junk files in dist (can appear on synced filesystems).
  await removeSpaceNamedFilesRec(distDir);

  const relFiles = (await listFilesRec(distDir, distDir))
    .map((p) => p.split(path.sep).join("/"))
    .filter(Boolean);

  const precacheFiles = relFiles
    .filter((p) => p !== "sw.js")
    .filter((p) => !p.endsWith(".map"))
    .filter((p) => !p.startsWith(".vite/"));

  precacheFiles.sort();

  if (!precacheFiles.includes("index.html")) {
    throw new Error("[pwa] dist/index.html not found");
  }

  const hasher = crypto.createHash("sha256");
  for (const rel of precacheFiles) {
    const abs = path.join(distDir, rel);
    const data = await fs.readFile(abs);
    hasher.update(rel);
    hasher.update("\0");
    hasher.update(crypto.createHash("sha256").update(data).digest());
    hasher.update("\0");
  }
  const buildHash = hasher.digest("hex").slice(0, 12);
  const buildId = `${version}-${buildHash}`;

  const precacheUrls = precacheFiles.map((p) => `./${p}`);

  const sw = `/* eslint-disable */
/* Generated by client-web/scripts/build_pwa.mjs. Do not edit by hand. */

const BUILD_ID = ${JSON.stringify(buildId)};
const CACHE_PREFIX = "yagodka-web-cache-";
const CACHE = CACHE_PREFIX + BUILD_ID;
const PRECACHE_URLS = ${JSON.stringify(precacheUrls, null, 2)};
const RUNTIME_CACHE = CACHE_PREFIX + "runtime";
const RUNTIME_LIMIT = 220;
const RUNTIME_MAX_BYTES = 8 * 1024 * 1024;
const RUNTIME_EXT_RE = /\.(js|css|jpe?g|png|gif|webp|avif|svg|ico|woff2?|ttf|otf|wasm|webmanifest)(?:\?.*)?$/i;
const RUNTIME_PATH_RE = /^\\/(assets|icons|skins)\\//i;
const RUNTIME_SPECIAL = new Set(["/manifest.webmanifest", "/sw.js"]);
const SHARE_PATH_RE = /\\/share\\/?$/i;
const SHARE_FALLBACK_ID = "__broadcast__";
const shareQueue = new Map();

function isNavigationRequest(req) {
  return req.mode === "navigate" || req.destination === "document";
}

function isStaticAssetUrl(url) {
  const path = url.pathname || "/";
  if (RUNTIME_SPECIAL.has(path)) return true;
  if (RUNTIME_PATH_RE.test(path)) return true;
  return RUNTIME_EXT_RE.test(path);
}

function isCacheableResponse(res) {
  if (!res || !res.ok) return false;
  const cc = String(res.headers.get("cache-control") || "").toLowerCase();
  if (cc.includes("no-store")) return false;
  if (cc.includes("private")) return false;
  const len = Number(res.headers.get("content-length") || 0);
  if (len && len > RUNTIME_MAX_BYTES) return false;
  return true;
}

async function trimRuntimeCache(cache) {
  try {
    const keys = await cache.keys();
    if (keys.length <= RUNTIME_LIMIT) return;
    const overflow = keys.length - RUNTIME_LIMIT;
    for (let i = 0; i < overflow; i += 1) {
      const req = keys[i];
      await cache.delete(req);
    }
  } catch {}
}

function normalizeSharePayload(formData) {
  const files = [];
  try {
    for (const f of formData.getAll("files") || []) {
      if (f && typeof f === "object" && typeof f.arrayBuffer === "function") files.push(f);
    }
  } catch {}
  const title = String(formData.get("title") || "").trim();
  const text = String(formData.get("text") || "").trim();
  const url = String(formData.get("url") || "").trim();
  return { files, title, text, url };
}

function enqueueShare(clientId, payload) {
  const key = clientId || SHARE_FALLBACK_ID;
  const arr = shareQueue.get(key) || [];
  arr.push(payload);
  shareQueue.set(key, arr.slice(-8));
}

async function postShareToClient(client, payloads) {
  if (!client || !payloads || !payloads.length) return;
  for (const payload of payloads) {
    try {
      client.postMessage({ type: "PWA_SHARE", payload });
    } catch {}
  }
}

async function flushShareQueue(client) {
  if (!client) return;
  const own = shareQueue.get(client.id) || [];
  const fallback = shareQueue.get(SHARE_FALLBACK_ID) || [];
  if (!own.length && !fallback.length) return;
  shareQueue.delete(client.id);
  shareQueue.delete(SHARE_FALLBACK_ID);
  await postShareToClient(client, [...own, ...fallback]);
}

async function handleShareFetch(event) {
  try {
    const formData = await event.request.formData();
    const payload = normalizeSharePayload(formData);
    const clientId = event.resultingClientId || "";
    enqueueShare(clientId, payload);
    if (clientId) {
      const client = await self.clients.get(clientId);
      if (client) await flushShareQueue(client);
    } else {
      const clients = await self.clients.matchAll({ type: "window", includeUncontrolled: true });
      if (clients && clients.length) {
        for (const c of clients) {
          await flushShareQueue(c);
        }
      }
    }
  } catch {}
  return Response.redirect("./", 303);
}

self.addEventListener("install", (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(CACHE);
      await cache.addAll(PRECACHE_URLS);
      // Telegram-like: activate the new SW immediately, but *do not* force reload here.
      // The app decides when it's safe to restart (idle / no transfers / no focused input).
      await self.skipWaiting();
    })()
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    (async () => {
      try {
        const keys = await caches.keys();
        await Promise.all(
          keys
            .filter((k) => k.startsWith(CACHE_PREFIX) && k !== CACHE)
            .map((k) => caches.delete(k))
        );
      } catch {}
      await self.clients.claim();
    })()
  );
});

self.addEventListener("message", (event) => {
  const data = event && event.data ? event.data : null;
  if (!data || typeof data !== "object") return;
  if (data.type === "SKIP_WAITING") {
    self.skipWaiting();
    return;
  }
  if (data.type === "GET_BUILD_ID") {
    const payload = { type: "BUILD_ID", buildId: BUILD_ID };
    try {
      if (event && event.source && typeof event.source.postMessage === "function") {
        event.source.postMessage(payload);
        return;
      }
      if (event && event.ports && event.ports[0] && typeof event.ports[0].postMessage === "function") {
        event.ports[0].postMessage(payload);
        return;
      }
    } catch {}
    self.clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((clients) => clients.forEach((c) => c.postMessage(payload)))
      .catch(() => {});
  }
  if (data.type === "PWA_SHARE_READY") {
    const source = event && event.source;
    if (source && typeof source.id === "string") {
      flushShareQueue(source);
    }
  }
});

self.addEventListener("fetch", (event) => {
  const req = event.request;
  if (!req) return;
  const url = new URL(req.url);
  if (url.origin !== self.location.origin) return;

  if (SHARE_PATH_RE.test(url.pathname)) {
    if (req.method === "POST") {
      event.respondWith(handleShareFetch(event));
    }
    return;
  }

  if (req.method !== "GET") return;

  // App shell: отдаём index.html из кэша, чтобы не смешивать версии index+assets.
  if (isNavigationRequest(req)) {
    event.respondWith(
      (async () => {
        const cache = await caches.open(CACHE);
        const cachedIndex = await cache.match("./index.html");
        if (cachedIndex) return cachedIndex;
        return fetch(req);
      })()
    );
    return;
  }

  if (!isStaticAssetUrl(url)) return;

  event.respondWith(
    (async () => {
      const precache = await caches.open(CACHE);
      const cachedPre = await precache.match(req);
      if (cachedPre) return cachedPre;
      const cache = await caches.open(RUNTIME_CACHE);
      const cached = await cache.match(req);
      if (cached) return cached;
      const res = await fetch(req);
      if (isCacheableResponse(res)) {
        try {
          cache.put(req, res.clone());
          trimRuntimeCache(cache);
        } catch {}
      }
      return res;
    })()
  );
});
`;

  await fs.writeFile(path.join(distDir, "sw.js"), sw, "utf8");
  // eslint-disable-next-line no-console
  console.log(`[pwa] sw.js generated (build=${buildId}, precache=${precacheUrls.length})`);
}

main().catch((e) => {
  // eslint-disable-next-line no-console
  console.error(String(e?.stack || e));
  process.exit(2);
});
